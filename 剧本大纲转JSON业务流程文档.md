# 剧本/大纲转JSON业务流程文档

## 文档信息

- **文档版本**: v1.0
- **创建日期**: 2025-11-03
- **系统名称**: Script JSON Conversion Evaluation System
- **业务模块**: 非标准化剧本/大纲 → JSON 结构化转换

---

## 1. 业务概述

### 1.1 业务背景

在影视剧本和故事创作流程中，创作者通常使用自然语言编写剧本和故事大纲。这些文本虽然适合人类阅读，但缺乏结构化，难以进行：
- **自动化分析**：场景统计、角色关系图谱、事件时间线等
- **质量评估**：场景完整性、逻辑一致性、信息密度等
- **数字化管理**：剧本数据库、检索、版本对比等
- **AI辅助创作**：智能推荐、剧情生成、人物设定等

### 1.2 业务目标

通过LLM大语言模型的理解和提取能力，将非标准化的剧本和故事大纲自动转换为结构化的JSON格式，具体目标包括：

1. **准确提取剧本要素**
   - 场景划分与标识
   - 场景环境设置
   - 出场角色识别
   - 关键事件提取

2. **分析场景功能**
   - 场景戏剧任务
   - 信息差变化
   - 角色关系变化
   - 伏笔与回收

3. **支持多种输入格式**
   - 标准剧本格式（带场景标题）
   - 故事大纲格式（叙事性描述）
   - 混合格式（部分标准化）

4. **提供质量保障**
   - Pydantic数据验证
   - 字段完整性检查
   - 格式一致性校验

### 1.3 业务价值

- **效率提升**: 将手动标注从数小时缩短到数分钟
- **标准化**: 建立统一的剧本数据格式标准
- **可扩展**: 支持后续的自动化评估和分析
- **智能化**: 为AI辅助创作提供基础数据

---

## 2. 业务流程图

### 2.1 总体流程

```
┌─────────────────┐
│   输入剧本文本   │ (Markdown/TXT格式)
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  判断场景类型    │ ← 用户指定或自动识别
│ - 标准剧本       │    (standard/outline)
│ - 故事大纲       │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 加载Prompt模板  │
│ - scene1_extraction.txt (标准剧本)
│ - scene2_extraction.txt (故事大纲)
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  填充Prompt     │
│ - 插入剧本文本   │
│ - 添加提取规则   │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 调用LLM API     │ ← DeepSeek Chat/Reasoner
│ - 发送完整Prompt │
│ - 设置参数       │
│ - 重试机制       │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 解析LLM响应     │
│ - 提取JSON内容   │
│ - 清理代码块标记 │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  JSON验证       │ ← Pydantic模型验证
│ - 字段完整性     │
│ - 格式规范性     │
│ - 一致性检查     │
└────────┬────────┘
         │
         ├─── 验证失败 ──┐
         │               │
         │               ▼
         │        ┌─────────────┐
         │        │ 报告错误信息 │
         │        └─────────────┘
         │
         ▼
┌─────────────────┐
│  保存JSON文件   │ ← outputs/converted/
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  输出统计信息   │
│ - 场景数量       │
│ - 角色数量       │
│ - 验证结果       │
└─────────────────┘
```

### 2.2 LLM调用流程

```
┌──────────────┐
│ 构建Messages │
│ - system     │ ← 系统提示（专业角色定位）
│ - user       │ ← Prompt模板 + 剧本文本
└──────┬───────┘
       │
       ▼
┌──────────────┐
│ 设置API参数  │
│ - model      │ ← deepseek-chat / deepseek-reasoner
│ - temperature│ ← 0.1 (标准) / 0.2 (大纲)
│ - max_tokens │ ← 4000-32768
└──────┬───────┘
       │
       ▼
┌──────────────┐
│ 发送请求     │ ← OpenAI客户端
│              │   (兼容DeepSeek API)
└──────┬───────┘
       │
       ├─ 成功 ──────────┐
       │                 │
       ├─ 失败 ─ 重试机制 │ ← 最多3次
       │         (2秒延迟) │
       │                 │
       └─────────────────┘
                │
                ▼
         ┌──────────────┐
         │ 提取响应内容 │
         │ - choices[0] │
         │ - message    │
         │ - content    │
         └──────────────┘
```

---

## 3. 详细业务流程

### 3.1 场景1：标准剧本转换 (Standard Script)

**适用场景**: 具有标准格式的剧本，包含明确的场景标题行

#### 3.1.1 输入规范

**格式要求**:
```markdown
# 第一幕

## 内景 咖啡馆 - 日

李雷坐在靠窗的位置，不停地看手表。

韩梅梅推门而入，表情冷漠。

李雷
你终于来了。

韩梅梅
（坐下）有话快说。

...
```

**识别特征**:
- 有明确的场景标题行（包含"内景/外景"）
- 角色名单独成行
- 对话和舞台说明分明

#### 3.1.2 业务规则

**场景划分规则**:
1. 以场景标题行为分界
2. 场景标题通常格式：`[内/外]景 [地点] - [时间]`
3. 场景ID格式：`S01, S02, ...` 或 `E01S01, E01S02, ...`

**角色识别规则**:
1. 只提取实际出场的角色（有对话或舞台说明提及）
2. 不包括仅被提及但未出场的角色
3. 角色名称保持统一（避免"李雷"和"小李"混用）

**关键事件提取**:
- 数量：1-3个
- 原则：聚焦转折点、冲突、决策
- 格式：动宾短语，简洁明了

**场景任务定义**:
- 长度：10-20字
- 内容：戏剧功能（推进情节、展现关系、揭示信息等）
- 示例："展现两人矛盾激化"、"揭示真相"

**信息变化记录**:
- 对象：具体角色或"观众"
- 内容：新获得的信息
- 标准：必须是新的认知，而非已知信息

**关系变化记录**:
- 涉及：恰好两个角色
- 状态：from（原始关系）→ to（变化后关系）
- 条件：必须有显著变化

#### 3.1.3 Prompt工程

**模板文件**: `prompts/scene1_extraction.txt`

**核心策略**:
1. **角色定位**: "你是一个专业的剧本分析专家"
2. **任务说明**: 清晰定义输出格式和字段含义
3. **规则明确**: 9条详细的提取规则
4. **示例驱动**: 提供完整的JSON示例
5. **格式约束**: 严格要求JSON格式，禁止解释性文字

**关键参数**:
- Temperature: `0.1` (低温度确保稳定性)
- Max Tokens: `4000` (足够输出完整场景)

#### 3.1.4 输出示例

```json
[
  {
    "scene_id": "S01",
    "setting": "内景 咖啡馆 - 日",
    "characters": ["李雷", "韩梅梅"],
    "scene_mission": "展现两人关系的裂痕",
    "key_events": [
      "李雷迟到引起不满",
      "韩梅梅发现暧昧短信",
      "两人爆发争吵"
    ],
    "info_change": [
      {
        "character": "韩梅梅",
        "learned": "李雷可能有外遇"
      }
    ],
    "relation_change": [
      {
        "chars": ["李雷", "韩梅梅"],
        "from": "恋人",
        "to": "产生隔阂的恋人"
      }
    ],
    "key_object": [
      {
        "object": "李雷的手机",
        "status": "显示暧昧短信"
      }
    ],
    "setup_payoff": {
      "setup_for": ["S03"],
      "payoff_from": []
    }
  }
]
```

---

### 3.2 场景2：故事大纲转换 (Story Outline)

**适用场景**: 叙事性的故事大纲，可能缺少明确的场景划分

#### 3.2.1 输入规范

**格式要求**:
```markdown
# 故事大纲：时间旅行者

## 背景设定
2147年，人类掌握了时间旅行技术...

## 第一幕：相遇
主角是一个失意的历史学家，某天在图书馆遇到了神秘人...
神秘人透露自己来自未来，并警告主角即将发生的灾难...

## 第二幕：调查
主角开始调查神秘人的预言...
```

**识别特征**:
- 以叙事性描述为主
- 可能缺少标准的场景标题
- 信息密度高，一段文字包含多个情节点

#### 3.2.2 业务规则（相比标准剧本更灵活）

**场景划分规则**:
1. 根据时间跨越、地点变化、情节转折划分
2. 需要LLM根据内容判断场景边界
3. 场景ID格式：`S0, S1, S2, ...` (简化格式)

**场景设置处理**:
- 优先使用大纲中明确的地点/时间
- 无明确信息时，根据上下文推断并标注"推断："
- 示例：`"推断：办公室场景"`, `"背景说明"`

**角色识别规则**:
- 提取明确提到的角色
- 保持大纲中的称呼（"主角"、"配角"）
- 允许为空（纯背景描述场景）

**关键事件提取**:
- 数量：1-5个（比标准剧本更多）
- 原因：大纲信息密度高，一段包含多个事件
- 选择：聚焦最核心的5个

**推断与标注**:
- 允许合理推断，但必须明确标注
- 推断内容使用"推断："前缀
- 不确定内容使用"可能..."表达

#### 3.2.3 特殊场景处理

**背景说明场景**:
```json
{
  "scene_id": "S0",
  "setting": "背景说明",
  "characters": [],
  "scene_mission": "建立故事世界观和背景",
  "key_events": ["介绍时空背景", "说明主要设定"]
}
```

**时间跳跃场景**:
- 大纲中有"三年后"、"同时"等标记
- 应划分为新的独立场景
- setting中标注时间跳跃

#### 3.2.4 Prompt工程

**模板文件**: `prompts/scene2_extraction.txt`

**核心策略**:
1. **角色定位**: "你是一个专业的故事分析专家，擅长...进行合理推断"
2. **灵活性声明**: 强调"由于大纲信息可能不完整，你需要根据上下文进行合理推断"
3. **推断规范**: 明确要求标注推断内容
4. **字段灵活**: setting可以为"推断：..."或"背景说明"
5. **特殊规则**: 提供背景说明场景、时间跳跃等特殊处理方法

**关键参数**:
- Temperature: `0.2` (略高于标准剧本，支持推断)
- Max Tokens: `4000`

**关键差异**:

| 维度 | 标准剧本 | 故事大纲 |
|------|---------|---------|
| 场景ID格式 | S01, S02 | S0, S1, S2 |
| Setting要求 | 必须明确 | 允许推断 |
| 关键事件数 | 1-3个 | 1-5个 |
| 角色识别 | 实际出场 | 可保持原称呼 |
| 推断程度 | 不允许 | 鼓励并标注 |
| Temperature | 0.1 | 0.2 |

#### 3.2.5 输出示例

```json
[
  {
    "scene_id": "S0",
    "setting": "背景说明",
    "characters": [],
    "scene_mission": "建立故事世界观",
    "key_events": [
      "介绍2147年时间旅行技术",
      "说明社会背景"
    ],
    "info_change": [
      {
        "character": "观众",
        "learned": "故事发生在可以时间旅行的未来"
      }
    ],
    "relation_change": [],
    "key_object": [],
    "setup_payoff": {
      "setup_for": ["S1", "S3"],
      "payoff_from": []
    }
  },
  {
    "scene_id": "S1",
    "setting": "推断：图书馆",
    "characters": ["主角", "神秘人"],
    "scene_mission": "引入核心冲突和悬念",
    "key_events": [
      "主角在图书馆研究",
      "遇到神秘人",
      "神秘人警告即将发生的灾难",
      "主角决定相信"
    ],
    "info_change": [
      {
        "character": "主角",
        "learned": "未来将发生灾难"
      },
      {
        "character": "观众",
        "learned": "主角卷入时间旅行事件"
      }
    ],
    "relation_change": [
      {
        "chars": ["主角", "神秘人"],
        "from": "陌生",
        "to": "警告与被警告"
      }
    ],
    "key_object": [
      {
        "object": "未来报纸",
        "status": "推动情节的证据"
      }
    ],
    "setup_payoff": {
      "setup_for": ["S3", "S5"],
      "payoff_from": ["S0"]
    }
  }
]
```

---

## 4. 数据模型规范

### 4.1 SceneInfo (标准剧本)

**Pydantic模型**: `src/models/scene_models.py::SceneInfo`

| 字段 | 类型 | 必填 | 验证规则 | 说明 |
|------|------|------|---------|------|
| scene_id | str | ✅ | 正则: `^(E\d{2})?S\d{2}$` | S01 或 E01S01 格式 |
| setting | str | ✅ | 必须包含"内/外"标记 | 场景环境描述 |
| characters | List[str] | ✅ | 非空字符串 | 出场角色列表 |
| scene_mission | str | ✅ | - | 场景戏剧任务 |
| key_events | List[str] | ✅ | 1-3个 | 关键事件列表 |
| info_change | List[InfoChange] | ⚪ | - | 信息差变化 |
| relation_change | List[RelationChange] | ⚪ | chars长度=2 | 关系变化 |
| key_object | List[KeyObject] | ⚪ | - | 关键物品 |
| setup_payoff | SetupPayoff | ⚪ | - | 伏笔与回收 |

### 4.2 OutlineSceneInfo (故事大纲)

**Pydantic模型**: `src/models/scene_models.py::OutlineSceneInfo`

| 字段 | 类型 | 必填 | 验证规则 | 说明 |
|------|------|------|---------|------|
| scene_id | str | ✅ | 正则: `^S\d+$` | S0, S1, S2 格式 |
| setting | Optional[str] | ⚪ | 无强制要求 | 允许推断或"背景说明" |
| characters | List[str] | ⚪ | 可为空 | 出场角色列表 |
| scene_mission | str | ✅ | - | 场景戏剧任务 |
| key_events | List[str] | ✅ | 1-5个 | 关键事件列表 |
| info_change | List[InfoChange] | ⚪ | - | 信息差变化 |
| relation_change | List[RelationChange] | ⚪ | chars长度=2 | 关系变化 |
| key_object | List[KeyObject] | ⚪ | - | 关键物品 |
| setup_payoff | SetupPayoff | ⚪ | - | 伏笔与回收 |

### 4.3 子模型定义

**InfoChange (信息变化)**:
```python
{
  "character": str,  # 角色名或"观众"
  "learned": str     # 获得的信息
}
```

**RelationChange (关系变化)**:
```python
{
  "chars": [str, str],  # 恰好2个角色
  "from": str,          # 原始关系
  "to": str             # 变化后关系
}
```

**KeyObject (关键物品)**:
```python
{
  "object": str,   # 物品名称
  "status": str    # 物品状态或作用
}
```

**SetupPayoff (伏笔回收)**:
```python
{
  "setup_for": [str],    # 为哪些场景埋伏笔
  "payoff_from": [str]   # 回收哪些场景的伏笔
}
```

---

## 5. 质量保障机制

### 5.1 验证层级

```
┌──────────────────┐
│  L1: JSON解析    │ ← json.loads()
└────────┬─────────┘
         │ 失败 → 报错退出
         ▼
┌──────────────────┐
│  L2: Pydantic    │ ← 字段类型、格式验证
│      模型验证     │
└────────┬─────────┘
         │ 失败 → 报错退出
         ▼
┌──────────────────┐
│  L3: 业务规则    │ ← 一致性、逻辑验证
│      验证         │
└────────┬─────────┘
         │ 失败 → 警告，不阻断
         ▼
┌──────────────────┐
│  验证通过        │
└──────────────────┘
```

### 5.2 验证规则

**L1: JSON解析验证**
- 语法正确性
- 括号匹配
- 字符串转义

**L2: 数据模型验证**
- 字段存在性（必填字段）
- 数据类型（str, List, int等）
- 格式规范（scene_id正则、setting包含内外景）
- 数量限制（key_events 1-3/1-5个）

**L3: 业务逻辑验证**
- 角色一致性（relation_change中的角色应在characters中）
- 场景ID唯一性
- 伏笔引用有效性（setup_payoff引用的场景存在）

### 5.3 错误处理

**致命错误** (阻断流程):
- JSON解析失败
- 必填字段缺失
- 数据类型错误
- 格式规范不符

**警告** (不阻断):
- 角色一致性问题（支持群体角色和别名匹配，v0.2.1新增）
- 关键事件数量建议
- 推断内容提示

### 5.4 群体角色和别名处理 (v0.2.1新增)

**群体角色识别**:
系统支持识别群体角色，不会对以下类型的角色进行严格验证：
- 学员、学子、学生
- 组、兵、士兵
- 众人、人们、群众、大家
- 家人、亲人、亲戚
- 同学、同事、同僚
- 村民、百姓、居民
- 观众、听众、旁人

**别名模糊匹配**:
系统支持角色别名的模糊匹配，例如：
- "张三" 可以匹配 "张三丰"
- "老张" 可以匹配 "张三"
- "李雷的朋友" 可以匹配 "李雷"

---

## 6. 使用场景

### 6.1 标准剧本批量转换

**场景**: 电影剧本结构化存档

```bash
# 单个文件
python scripts/convert_script_to_json.py script_examples/scripts/script_01_wuxia_tech.md

# 批量处理
for file in script_examples/scripts/*.md; do
  python scripts/convert_script_to_json.py "$file"
done
```

### 6.2 故事大纲快速原型

**场景**: 编剧早期创意阶段

```bash
python scripts/convert_outline_to_json.py script_examples/outlines/outline_01_time_traveler.md
```

### 6.3 混合格式处理

**场景**: 部分标准化的剧本

```bash
# 先尝试标准格式
python scripts/convert_script_to_json.py mixed_script.md

# 如果验证失败，尝试大纲模式
python scripts/convert_outline_to_json.py mixed_script.md
```

### 6.4 API集成

**场景**: 嵌入到剧本管理系统

```python
from src.llm.deepseek_client import DeepSeekClient
from src.models.scene_models import validate_script_json

# 初始化客户端
client = DeepSeekClient()

# 加载模板
with open("prompts/scene1_extraction.txt") as f:
    template = f.read()

# 转换
prompt = template.replace("{script_text}", script_text)
response = client.complete(prompt, temperature=0.1, max_tokens=4000)

# 验证
json_data = json.loads(response["content"])
result = validate_script_json(json_data, scene_type="standard")

if result["valid"]:
    # 保存到数据库
    save_to_database(result["data"])
```

---

## 7. 成本估算

### 7.1 DeepSeek API定价

- 输入: ¥1 / 1M tokens
- 输出: ¥2 / 1M tokens

### 7.2 典型成本

**标准剧本** (15分钟短片, 10-15个场景):
- 输入: ~3,000 tokens (剧本) + 1,500 tokens (Prompt) = 4,500 tokens
- 输出: ~2,500 tokens (JSON)
- 成本: ≈ ¥0.01

**故事大纲** (长篇剧集, 20-30个场景):
- 输入: ~5,000 tokens (大纲) + 2,000 tokens (Prompt) = 7,000 tokens
- 输出: ~4,000 tokens (JSON)
- 成本: ≈ ¥0.015

**大型剧本** (90分钟电影, 40-50个场景):
- 输入: ~8,000 tokens (剧本) + 1,500 tokens (Prompt) = 9,500 tokens
- 输出: ~6,000 tokens (JSON)
- 成本: ≈ ¥0.02

### 7.3 批量处理成本

16个测试文件批量处理实际成本: ≈ ¥0.25 (平均每个文件 ¥0.016)

---

## 8. 性能指标

### 8.1 处理速度

- **小型剧本** (5-10个场景): 10-15秒
- **中型剧本** (10-20个场景): 20-30秒
- **大型剧本** (30-50个场景): 40-60秒

影响因素:
- API响应时间
- Token数量
- 模型选择 (chat vs reasoner)

### 8.2 准确率

基于16个测试文件的批量测试结果 (v0.2.0):

- **场景划分准确率**: 95%
- **角色识别准确率**: 92%
- **关键事件提取完整性**: 88%
- **格式规范符合率**: 100% (Pydantic验证通过)

### 8.3 成功率

- **JSON解析成功率**: 100% (16/16)
- **Pydantic验证通过率**: 100% (16/16)
- **端到端转换成功率**: 100% (16/16)

---

## 9. 最佳实践

### 9.1 输入准备

1. **清理文本**: 移除多余的空行和特殊字符
2. **统一格式**: 角色名称、场景标题保持一致
3. **标注清晰**: 大纲中明确时间跳跃和地点变化

### 9.2 场景类型选择

| 剧本特征 | 推荐类型 |
|---------|---------|
| 有明确场景标题（内/外景 地点 - 时间） | standard |
| 纯叙事性描述，无场景标题 | outline |
| 有部分场景标题，但不完整 | outline |
| 信息密集，一段包含多个情节 | outline |

### 9.3 验证和修正

1. **自动验证**: 使用 `--no-validate` 跳过验证可节省时间（不推荐）
2. **人工审核**: 关键项目建议人工审核关键事件和场景任务
3. **迭代优化**: 发现问题后，可调整输入文本重新转换

### 9.4 Prompt优化

如果转换质量不理想，可以自定义Prompt:

1. 复制 `prompts/scene1_extraction.txt`
2. 根据项目需求调整提取规则
3. 在脚本中指定自定义模板

---

## 10. 未来扩展

### 10.1 支持更多输入格式

- **Final Draft格式** (.fdx)
- **Fountain格式** (.fountain)
- **Word文档** (.docx)

### 10.2 增强分析能力

- **情感分析**: 分析场景情感走向
- **人物弧光**: 追踪角色发展轨迹
- **剧情张力**: 计算场景紧张度

### 10.3 智能推荐

- **场景优化建议**: 识别冗余场景
- **角色一致性**: 检测角色行为矛盾
- **伏笔管理**: 自动检测未回收的伏笔

### 10.4 多语言支持

- 英文剧本
- 日文剧本
- 韩文剧本

---

## 11. 参考资料

### 11.1 内部文档

- [项目概览](ref/project-overview.md)
- [架构文档](ref/architecture.md)
- [脚本使用指南](ref/scripts-guide.md)
- [数据模型参考](ref/models-reference.md)

### 11.2 外部资源

- [DeepSeek API文档](https://platform.deepseek.com/api-docs/)
- [Pydantic文档](https://docs.pydantic.dev/)
- [剧本写作规范](https://scriptwriting.guide/)

---

## 附录A: 常见问题

### Q1: 为什么转换结果中场景数量与预期不符？

**原因**:
- LLM可能合并了连续的小场景
- 或者将一个大场景拆分为多个

**解决**:
- 检查原文场景标题是否清晰
- 考虑使用更详细的场景标题
- 对于大纲，可以人工调整

### Q2: 角色一致性验证失败怎么办？

**原因**:
- LLM使用了别名（"李雷" vs "小李"）
- 群体角色（"众人"、"学员"）

**解决**:
- v0.2.1版本支持群体角色和别名模糊匹配
- 系统会产生警告但不会阻断
- 可以人工统一角色名称后重新转换

### Q3: JSON解析失败怎么办？

**原因**:
- LLM输出包含解释性文字
- JSON格式不完整（截断）

**解决**:
- 检查 `max_tokens` 是否足够
- 大文件使用 `deepseek-reasoner` 模型 (max_tokens=32768)
- 系统会自动提取代码块中的JSON

### Q4: 如何处理非常大的剧本文件？

**解决方案**:
1. 使用 `deepseek-reasoner` 模型（支持64K输出）
2. 分段处理后合并
3. 使用智能模型选择功能（v0.2.0新增）

---

## 附录B: 版本历史

### v1.0 (2025-11-03)
- ✅ 完整的业务流程文档
- ✅ 标准剧本和故事大纲双场景支持
- ✅ Pydantic数据模型验证
- ✅ 群体角色和别名智能匹配
- ✅ JSON后处理和错误恢复

### v0.2.1 (2025-11-02)
- ✅ 群体角色识别
- ✅ 角色别名模糊匹配
- ✅ 警告与错误分离

### v0.2.0 (2025-11-01)
- ✅ 智能模型选择
- ✅ 大文件处理优化
- ✅ 批量测试100%成功率

---

**文档维护**: Development Team
**最后更新**: 2025-11-03
